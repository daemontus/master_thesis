In this section, we describe the algorithm used for the parameter synthesis computation.

\section{Environment and data structures}

The algorithm presented in this work assumes a distributed environment of $N$ independent, reliable agents connected using reliable communication channels. In practice, such model is suitable to model multi core machines and small to medium computational clusters where fault tolerance is not strictly necessary. In the end of this chapter, we will shortly explore the possibilities of adapting the algorithm to possible agent failure. 

We assume that each agent has locally access to the following data structures:

\begin{itemize}
	\item Total number of communicating agents $N$;
	\item A unique agent identifier $id \in \{ 1, \ldots, N \}$;
	\item A partition function $f : \dtsS \to \{1, \ldots, N \}$
	\item A \ac{PDTS} fragment $\mathcal{K}_i$;
	\item A \ac{HUCTLp} formula $\varphi$;
	\item An initial parameter constrain $\Phi_I$;
\end{itemize}

Note that not all of these structures have to be represented explicitly. For example, the \ac{PDTS} fragment and the partition function is usually computed on-the-fly.

\section{Assumption semantics}

In order to represent the intermediate results during the computation and accommodate for the distributed nature of the \ac{PDTS} fragments, we introduce the notion of assumptions and related assumption semantic function for the \ac{HUCTLp} formulae.

\subsection{Assumption function}

We define an assumption function for fragment $i$ as $\assume_i(\psi, h, s) = (\Phi^\top, \Phi^\bot)$, meaning that the \ac{HUCTLp} property $\psi$ is assumed to hold in state $s \in \dtsS$ and valuation $h : \var \to \dtsS$ under parameter valuations $p \in \pdtsP$ such that $p \models \Phi^\top$ and symmetrically, $\psi$ is assumed \emph{not} to hold for parameter valuations $p \models \Phi^\bot$. Collectively, assumption functions of all fragments represent the total knowledge about the system accumulated so far.

We will write $\assumeT_i(\psi, h, s)$ and $\assumeF_i(\psi, h, s)$ to denote an assumption function which returns just the first parameter constrain $\Phi^\top$ or second parameter constrain $\Phi^\bot$ respectively. Finally, when the fragment identifier is clear from context, we can omit the subscript $i$.

We say that an assumption $\assume(\varphi, s, h) = (\Phi^\top, \Phi^\bot)$ about the \ac{PDTS} $\mathcal{K}$ is \emph{valid} when for all $p$ holds that

\begin{align*}
	(p \models \Phi^\top \Rightarrow (\mathcal{K}_p, s, h) \models \varphi) \land (p \models \Phi^\bot \Rightarrow (\mathcal{K}_p, s, h) \not\models \varphi) 
\end{align*}

From now on, we will only consider valid assumption functions unless stated otherwise. Furthermore, from this definition, we can conclude several important properties of valid assumption functions:

\begin{itemize}
	\item Assumption implies satisfaction, but satisfaction does not necessarily imply assumption.
	\item Parameter constrain $\assumeT(\psi, s, h) \land \assumeF(\psi, s, h)$ can never be satisfiable - i.e. $\psi$ cannot be assumed to be valid and invalid at the same time.
	\item Parameter constrain $\neg\assumeT(\psi, s, h) \land \neg\assumeF(\psi, s, h)$ can be satisfiable. This situation signifies that for some parameter valuations the result is yet \emph{unknown}. We will denote this parameter constrains as $\assumeU(\psi, s, h)$.
	\item These intuitive equalities hold only when the set of unknown parameter valuations is empty:
	
	\begin{align*}
		\assumeT(\psi, s, h) & \not\equiv \neg \assumeF(\psi, s, h) \\
		\assumeT(\psi, s, h) & \not\equiv \neg \assumeT(\neg \psi, s, h)
	\end{align*}
	
	The expression $\neg \assumeF(\psi, s, h)$ represents not only parameters for which $\psi$ is satisfied, but also parameters for which the result is unknown. Similarly, in the second case, $\neg \assumeT(\neg \psi, s, h)$ denotes not only parameters for which the $\neg \psi$ is not satisfied (hence $\psi$ is satisfied) but also unknown parameter valuations.
	
\end{itemize}

We assume a partial ordering on the set of all possible assumption functions over \ac{PDTS} fragment $\mathcal{K}$ based on the number of the unknown parameter valuations. Formally:

\begin{align*}
	\assume_1 < \assume_2 \iff & \forall \psi, s, h : \\
	 & |\{ p \mid p \models \assumeU_1(\psi, s, h) \}| < |\{ p \mid p \models \assumeU_2(\psi, s, h) \}|
\end{align*}

Under such ordering, the set of all assumption functions forms a complete lattice. 

Finally, we will use $\assume_0$ to denote an assumption function which has all results initialised to $(\ffalse, \ffalse)$, hence the set of the valid and invalid parameter valuations is empty and the set of the unknown parameter valuations is the whole parameter universe.

\subsection{Semantic function}

In order to compute the maximal valid assumption function for a \ac{PDTS} fragment $\mathcal{K}_i = \pdtsTuple$, we define a semantic function $\mathcal{C}_\mathcal{K}(\assume_{in}) = \assume_{out}$ which increases the given assumption (with respect to the ordering) while preserving assumption validity.

In this definition, we do not use the full operator set of \ac{HUCTLp}, but rather the simplified set of operators defined in section \ref{sec:huctlEnd}. The definition uses a special assignment operator $\assume(\psi, s, h) \Leftarrow \Phi$ which means that the parameter constrain $\Phi$ is added to the current assumptions, formally:

\begin{align*}
	\assume(\psi, s, h) \Leftarrow \Phi \equiv \assume(\psi, s, h) \gets \assume(\psi, s, h) \lor \Phi
\end{align*}

Also observe that this operation is monotonic with respect to the assumption function ordering, that is, the cardinality of the set of unknown parameter valuations cannot increase by applying $\Leftarrow$.

The definition itself is divided into several parts, based on the \ac{HUCTLp} operators it deals with. Each part declaratively defines the new assumption function $\assume_{out}$ based on the given $\assume_{in}$.

First part describes the initial assumptions of the system. Here, $p \in \dtsAP$ is an atomic proposition and $x \in Var$ is a state variable.

\begin{align*}
	\assumeT_{out}(true, s, h) & \Leftarrow \Phi_I \\
	\assumeF_{out}(true, s, h) & \Leftarrow \neg \Phi_I \\
	\assumeT_{out}(p, s, h) & \Leftarrow 
	\begin{cases}
		\Phi_I & p \in \dtsL(s) \\
		\ffalse & \texttt{otherwise} \\
	\end{cases}
	\\
	\assumeF_{out}(p, s, h) & \Leftarrow \neg \assumeT_{in}(p, s, h) \\
	\assumeT_{out}(x, s, h[ x \mapsto s' ]) & \Leftarrow
	\begin{cases}
		\Phi_I & s = s' \\
		\ffalse & \texttt{otherwise}
	\end{cases}
	\\
	\assumeF_{out}(x, s, h[ x \mapsto s']) & \Leftarrow \neg \assumeT_{in}(x, s, h[ x \mapsto s' ]) \\
\end{align*}

Please observe that in all cases, no unknown parameters are present. This naturally follows from the fact that the validity of the atomic formulae depends solely on the properties of the system and the variable valuation, and hence can be resolved unambiguously.

In the second part, we provide the semantics for the temporal operators:

\begin{align*}
	\assumeT_{out}(\withTime{t}\ctlE\dctlX{\chi} \varphi, s, h)  \Leftarrow & \bigvee_{s' \in \dtsS} \withTime{t}trans(s,s') \land [\withTime{t}dir(s, \chi, s') \land \assumeT_{in}(\varphi, s', h)] \\
	\assumeF_{out}(\withTime{t}\ctlE\dctlX{\chi} \varphi, s, h) \Leftarrow & \bigwedge_{s' \in \dtsS} \neg\withTime{t}trans(s,s') \lor [\withTime{t}dir(s, \chi, s') \Rightarrow \assumeF_{in}(\varphi, s', h)] \\
	%
	\assumeT_{out}(\withTime{t}\ctlA\dctlX{\chi} \varphi, s, h) \Leftarrow & \bigwedge_{s' \in \dtsS} \neg \withTime{t}trans(s,s') \lor [\withTime{t}dir(s, \chi, s') \land \assumeT_{in}(\varphi, s', h)] \\
	\assumeF_{out}(\withTime{t}\ctlA\dctlX{\chi} \varphi, s, h)  \Leftarrow & \bigvee_{s' \in \dtsS} \withTime{t}trans(s,s') \land [ \withTime{t}dir(s, \chi, s') \Rightarrow \assumeF_{in}(\varphi, s', h)] \\
	%
	\assumeT_{out}(\withTime{t}\ctlE\dctlFW{\chi} \varphi, s, h)  \Leftarrow &\ \assumeT_{in}(\varphi, s, h) \lor \\
	 & \bigvee_{s' \in \dtsS} \withTime{t}trans(s,s') \land [\withTime{t}dir(s, \chi, s') \Rightarrow \assumeT_{in}(\withTime{t}\ctlE\dctlFW{\chi} \varphi, s', h) ] \\
	 \assumeF_{out}(\withTime{t}\ctlE\dctlFW{\chi} \varphi, s, h)  \Leftarrow &\ \assumeF_{in}(\varphi, s, h) \land \\
	 & \bigwedge_{s' \in \dtsS} \neg\withTime{t}trans(s,s') \lor [\withTime{t}dir(s, \chi, s') \land \assumeF_{in}(\withTime{t}\ctlE\dctlFW{\chi} \varphi, s', h) ] \\
	 %
	 \assumeT_{out}(\withTime{t}\ctlA\dctlFW{\chi} \varphi, s, h)  \Leftarrow &\ \assumeT_{in}(\varphi, s, h) \lor \\
	 & \bigwedge_{s' \in \dtsS} \neg\withTime{t}trans(s,s') \lor [\withTime{t}dir(s, \chi, s') \Rightarrow \assumeT_{in}(\withTime{t}\ctlA\dctlFW{\chi} \varphi, s', h) ] \\
	 \assumeF_{out}(\withTime{t}\ctlA\dctlFW{\chi} \varphi, s, h)  \Leftarrow &\ \assumeF_{in}(\varphi, s, h) \land \\
	 & \bigvee_{s' \in \dtsS} \withTime{t}trans(s,s') \land [\withTime{t}dir(s, \chi, s') \land \assumeF_{in}(\withTime{t}\ctlA\dctlFW{\chi} \varphi, s', h) ] \\
	 %
	\assumeT_{out}(\withTime{t}\ctlE[ \varphi_1 \dctlUl{\chi} \varphi_2], s, h) \Leftarrow &\ \assumeT_{in}(\varphi_2, s, h) \lor \big[ \assumeT_{in}(\varphi_1, s, h) \land \\
	& \bigvee_{s' \in \dtsS} \withTime{t}trans(s,s') \land [\withTime{t}dir(s, \chi, s') \land \assumeT_{in}(\withTime{t}\ctlE[ \varphi_1 \dctlUl{\chi} \varphi_2], s', h)] \big] \\
	\assumeF_{out}(\withTime{t}\ctlE[ \varphi_1 \dctlUl{\chi} \varphi_2], s, h) \Leftarrow &\ \assumeF_{in}(\varphi_2, s, h) \land \big[ \assumeF_{in}(\varphi_1, s, h) \lor \\
	& \bigwedge_{s' \in \dtsS} \neg\withTime{t}trans(s,s') \lor [\withTime{t}dir(s, \chi, s') \Rightarrow \assumeF_{in}(\withTime{t}\ctlE[ \varphi_1 \dctlUl{\chi} \varphi_2], s', h)] \big] \\
	%
	\assumeT_{out}(\withTime{t}\ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2], s, h) \Leftarrow &\ \assumeT_{in}(\varphi_2, s, h) \lor \big[ \assumeT_{in}(\varphi_1, s, h) \land \\
	& \bigwedge_{s' \in \dtsS} \neg\withTime{t}trans(s,s') \lor [\withTime{t}dir(s, \chi, s') \land \assumeT_{in}(\withTime{t}\ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2], s', h)] \big] \\
	\assumeF_{out}(\withTime{t}\ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2], s, h) \Leftarrow &\ \assumeF_{in}(\varphi_2, s, h) \land \big[ \assumeF_{in}(\varphi_1, s, h) \lor \\
	& \bigvee_{s' \in \dtsS} \withTime{t}trans(s,s') \land [\withTime{t}dir(s, \chi, s') \Rightarrow \assumeF_{in}(\withTime{t}\ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2], s', h)] \big] \\
\end{align*}

As we can see, the differences between operators and their positive and negative semantics are often very subtle, but crucial.

First of all, let us observe that due to the negation inequality, we can't simply handle the negative assumptions as negations of the positive ones. Second, we see that the observations about the nature of weak operators made in the section \ref{sec:weak} are still valid—that is, one can clearly observe the strict ($\land$) and weak($\Rightarrow$) direction requirement in all definitions.

Finally, let us describe the semantics of the remaining boolean and hybrid operators:

\begin{align*}
	\assumeT_{out}(\neg \varphi, s, h) \Leftarrow & \assumeF_{in}(\varphi, s, h) \\
	\assumeF_{out}(\neg \varphi, s, h) \Leftarrow & \assumeT_{in}(\varphi, s, h) \\
	\assumeT_{out}(\varphi_1 \land \varphi_2, s, h) \Leftarrow & \assumeT_{in}(\varphi_1, s, h) \land \assumeT(\varphi_2, s, h) \\
	\assumeF_{out}(\varphi_1 \land \varphi_2, s, h) \Leftarrow & \assumeF_{in}(\varphi_1, s, h) \lor \assumeF(\varphi_2, s, h) \\
	\assumeT_{out}(\hctlBind{x} \varphi, s, h) \Leftarrow &\ \assumeT_{in}(\varphi, s, h[x \mapsto s]) \\
	\assumeF_{out}(\hctlBind{x} \varphi, s, h) \Leftarrow &\ \assumeF_{in}(\varphi, s, h[x \mapsto s]) \\
	\assumeT_{out}(\hctlExists{x} \varphi, s, h) \Leftarrow &\ \bigvee_{s' \in S} \assumeT_{in}(\varphi, s, h[x \mapsto s']) \\
	\assumeF_{out}(\hctlExists{x} \varphi, s, h) \Leftarrow &\ \bigwedge_{s' \in S} \assumeF_{in}(\varphi, s, h[x \mapsto s']) \\
	\assumeT_{out}(\hctlAt{x} \varphi, s, h[x \mapsto s']) \Leftarrow &\ \assumeT_{in}(\varphi, s', h[x \mapsto s']) \\
	\assumeF_{out}(\hctlAt{x} \varphi, s, h[x \mapsto s']) \Leftarrow &\ \assumeF_{in}(\varphi, s', h[x \mapsto s']) \\
\end{align*}

As we can see, the semantic function computed according to the rules presented in this section is clearly monotonic (thanks to the $\Leftarrow$ operator) with respect to the complete lattice formed by the assumption functions of $\mathcal{K}$. Therefore according to [CITE], $\mathcal{C}$ has a minimum fix point.

\subsection{Semantic function validity}

Even though the monotonicity of the semantic function is rather obvious, the validity of the resulting assumption function might not be entirely clear, especially for the temporal operators, which are originally defined using infinite runs rather than recursively based on the \ac{PDTS} transitions.

Lemma: Given a valid assignment $\assume_{in}$, the semantic function $\mathcal{C}(\assume_{in})$ produces a valid assignment.

First, we consider the validity of the atomic proposition assumptions and hybrid operator assumptions as obvious, since they can be almost directly translated to their original definitions. 

Next, we show a full validity proof for the positive assumption of the $\withTime{t}\ctlA\dctlUl{\chi}$ operator—one of the most complex temporal operators. Proofs for other operators (and their negative counterparts) are very similar.

\begin{itemize}
	\item Assume all current $\assumeT$ and $\assumeF$ are valid and we are considering $ \psi = \withTime{t} \ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2 ]$.
	\item For a contradiction, let us assume there exists a parameter valuation $p \in \pdtsP$ such that $p \models \assumeT(\psi, s, h)$ and $(\mathcal{K}_p, s, h) \not\models \psi$ for some $s$ and $h$.
	\item Then we have to consider two cases:
	\begin{itemize}
		\item $p \models \assumeT(\varphi_2, s, h)$ - this is in direct contradiction with the operator definition, since for all runs $\pi$ there exists $i = 0$ such that $(\mathcal{K}_p, \pi_\dtsS(i), h) \models \varphi_2$ because $\pi_\dtsS(0) = s$ (the direction requirement is trivially satisfied because there is not $j$ smaller than $0$).
		\item $p \models \big[ \assumeT(\varphi_1, s, h) \land \bigwedge_{s' \in \dtsS} \neg\withTime{t}trans(s,s') \lor [\withTime{t}dir(s, \chi, s') \land \assumeT(\withTime{t}\ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2], s', h)] \big]$. This means that not only $(\mathcal{K}_p, s, h) \models \varphi_1$, but also for all $s'$ either the the transition from $s$ is not present, or it is present, it satisfies the direction requirement, and $p \models \assumeT(\withTime{t}\ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2], s', h)$. Thanks to this, we see that every infinite run starting in $s$ has to use one of these transitions. Therefore either the assumption $\assumeT(\varphi_1, s, h)$ or some of the assumptions $\assumeT(\withTime{t}\ctlA[ \varphi_1 \dctlUl{\chi} \varphi_2], s', h)$ are not correct.
	\end{itemize}
\end{itemize}

\section{Main algorithm}

In this section, we present the main algorithm which relies on the previously defined assumption function and the assumption fix-point.

\begin{algorithmic}
	\label{alg:main}
	\Function{ParameterSynthesis}{fragment $\mathcal{K}_{id}$, property $\varphi$}
		\State $\assume \gets \assume_\bot$
		\Repeat
			\Repeat
				\State $\mathcal{\Call{FixPoint}{\assume}}$
				\State $\Call{MapReduce}{\assume}$
			\Until{\Call{TerminationDetection}{}}
			\State $\Call{IncreaseCycles}{\assume, \varphi}$
		\Until{\Call{TerminationDetection}{}}
		\State $\mathcal{F}(s) \gets \assumeT(\varphi, s, h_0)$
	\EndFunction
	\Function{FixPoint}{assumption function $\assume$}
		\Repeat
			\State $\assume_0 \gets \assume$
			\State $\assume \gets \mathcal{C}_{id}(\assume_0)$
		\Until{$\assume_0 = \assume$}
	\EndFunction
	\Function{MapReduce}{assumption function $\assume$}
		\State $Sent(i) \gets \assume_0$
		\ForAll{$s \in \dtsSlocal_{id}$}
			\ForAll{$i < N$ such that $s \in \dtsSborder_i$}
				\State $Sent(i, \psi, h, s) \gets \assume(\psi, h, s)$
			\EndFor
			\ForAll{$i < N$ and $\psi : (\hctlAt{x} \psi) \in cl(\varphi) $}
				\State $Sent(i, \psi, h, s) \gets \assume(\psi, h, s)$
			\EndFor
		\EndFor
		\State $\Call{Send}{Sent}$
		\State $Received \gets \Call{Receive}$
		\State $\assume(\psi, h, s) \Leftarrow \bigcup_{i < N} Received(i, \psi, h, s)$
	\EndFunction
	\Function{IncreaseCycles}{assumption function $\assume$, property $\varphi$}
		\State $Finished(h, s) \gets \ttrue $
		\ForAll{$\psi \in sub(\varphi)$}
			\State $Finished(h, s) = Finished(h, s) \land \neg \Call{IncreaseCycles}{\mathcal{A}, \psi}(h, s)$
		\EndFor
		\State $Unknown(h, s) \gets \neg \assumeT(\varphi, h, s) \land \neg \assumeF(\varphi, h, s)$		
		\State $\assumeF(\varphi, h, s) \Leftarrow Unknown(h, s) \land Finished(h,s)$
		\State \Return $Unknown$
	\EndFunction	
\end{algorithmic}

The algorithm starts with a fully unknown assignment and continues to the main loop, which iteratively computes new fix-point assumptions and performs necessary communication. As soon as no new information can be gained using this procedure, the algorithm will proceed to mark unknown parameter valuations as unsatisfied, assuming all sub-formulae have been successfully computed.